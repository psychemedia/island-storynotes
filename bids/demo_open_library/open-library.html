<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenLibrary Collection with Full-Text Search</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .search-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="url"],
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .search-button {
            background: #28a745;
        }

        .search-button:hover {
            background: #1e7e34;
        }

        .clear-button {
            background: #dc3545;
        }

        .clear-button:hover {
            background: #c82333;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .book-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .book-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        .book-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .book-card.highlighted {
            border: 2px solid #007bff;
            background: #f8f9ff;
        }

        .book-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .book-authors {
            color: #666;
            margin-bottom: 10px;
        }

        .book-links {
            margin-top: 15px;
        }

        .book-links a {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 5px;
            padding: 5px 10px;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 12px;
        }

        .book-links a:hover {
            background: #1e7e34;
        }

        .book-links a.openlibrary {
            background: #ffc107;
            color: #212529;
        }

        .book-links a.openlibrary:hover {
            background: #e0a800;
        }

        .book-status {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            padding: 5px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .book-status.indexed {
            color: #155724;
            background: #d4edda;
        }

        .book-status.failed {
            color: #721c24;
            background: #f8d7da;
        }

        .search-results {
            margin-top: 15px;
            padding: 10px;
            background: #e7f3ff;
            border-radius: 4px;
            font-size: 14px;
        }

        .search-snippet {
            background: #fff3cd;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
            font-size: 13px;
            border-left: 3px solid #ffc107;
        }

        .highlight {
            background: yellow;
            font-weight: bold;
        }

        .stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress {
            background: #e9ecef;
            border-radius: 4px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar {
            background: #007bff;
            height: 100%;
            transition: width 0.3s ease;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .db-status {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üìö OpenLibrary Collection with Full-Text Search</h1>
        <p>Load a collection, download full texts, and search across all books!</p>

        <div class="input-group">
            <label for="collectionUrl">Collection URL:</label>
            <input type="url" id="collectionUrl"
                placeholder="https://openlibrary.org/collections/folk-and-fairy-tales.json"
                value="https://openlibrary.org/collections/folk-and-fairy-tales.json">
        </div>

        <button onclick="loadCollection()">üì• Load Collection</button>
        <button onclick="downloadAllTexts()" class="search-button" id="downloadBtn" disabled>‚¨áÔ∏è Download All
            Texts</button>
        <button onclick="clearDatabase()" class="clear-button" id="clearBtn">üóëÔ∏è Clear Database</button>

        <div class="db-status" id="dbStatus">Database not initialized</div>
    </div>

    <div class="search-section" id="searchSection" style="display: none;">
        <h2>üîç Full-Text Search</h2>
        <div class="input-group">
            <label for="searchQuery">Search Query:</label>
            <input type="text" id="searchQuery" placeholder="Enter search terms..."
                onkeypress="handleSearchKeypress(event)">
        </div>
        <button onclick="performSearch()" class="search-button">Search Books</button>
        <button onclick="clearSearch()">Clear Results</button>

        <div id="searchResults" style="display: none;">
            <h3>Search Results</h3>
            <div id="searchResultsList"></div>
        </div>
    </div>

    <div id="stats" class="stats" style="display: none;">
        <strong>Collection:</strong> <span id="workCount">0</span> works |
        <strong>Texts Downloaded:</strong> <span id="indexedCount">0</span> books
        <div class="progress">
            <div id="progressBar" class="progress-bar" style="width: 0%">0%</div>
        </div>
        <div>Processing: <span id="currentTask">Ready</span></div>
    </div>

    <div id="loading" class="loading" style="display: none;">
        Loading...
    </div>

    <div id="error" class="error" style="display: none;"></div>
    <div id="success" class="success" style="display: none;"></div>

    <div id="bookGrid" class="book-grid"></div>

    <script  type="module">
        import sqlite3InitModule from 'https://cdn.jsdelivr.net/npm/@sqlite.org/sqlite-wasm@3.42.0-build2/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs';

        let db = null;
        let SQL = null;
        let processedBooks = [];
        let loadButton, downloadBtn, clearBtn;
        let collectionInput, searchQuery;
        let isSearching = false;

        // Load SQL.js dynamically
        async function loadSqlJsX() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js';
                script.onload = () => {
                    // SQL.js is now available as global initSqlJs
                    resolve(window.initSqlJs);
                };
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        document.addEventListener('DOMContentLoaded', async function () {
            loadButton = document.querySelector('button');
            downloadBtn = document.getElementById('downloadBtn');
            clearBtn = document.getElementById('clearBtn');
            collectionInput = document.getElementById('collectionUrl');
            searchQuery = document.getElementById('searchQuery');

            await initializeDatabase();
        });

    async function initializeDatabase() {
        try {
            updateCurrentTask('Loading database engine...');

            const sqlite3 = await sqlite3InitModule({
                locateFile: file => `https://cdn.jsdelivr.net/npm/@sqlite.org/sqlite-wasm@3.42.0-build2/sqlite-wasm/jswasm/${file}`
            });

            // Use the correct API for SQLite WASM
            db = new sqlite3.oo1.DB();
            window.db = db;

            // Create tables - use exec for DDL
            db.exec(`
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                ocaid TEXT UNIQUE,
                title TEXT,
                authors TEXT,
                work_key TEXT,
                edition_key TEXT,
                full_text TEXT,
                indexed_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

            db.exec(`
            CREATE VIRTUAL TABLE IF NOT EXISTS books_fts USING fts5(
                title, authors, full_text, 
                content='books', 
                content_rowid='id'
            )
        `);

            // Create triggers to keep FTS table in sync
            db.exec(`
            CREATE TRIGGER IF NOT EXISTS books_ai AFTER INSERT ON books BEGIN
                INSERT INTO books_fts(rowid, title, authors, full_text) 
                VALUES (new.id, new.title, new.authors, new.full_text);
            END
        `);

            db.exec(`
            CREATE TRIGGER IF NOT EXISTS books_ad AFTER DELETE ON books BEGIN
                DELETE FROM books_fts WHERE rowid = old.id;
            END
        `);

            db.exec(`
            CREATE TRIGGER IF NOT EXISTS books_au AFTER UPDATE ON books BEGIN
                UPDATE books_fts SET title=new.title, authors=new.authors, full_text=new.full_text 
                WHERE rowid = new.id;
            END
        `);

            updateDbStatus();
            updateCurrentTask('Database ready');
            console.log('Database initialized successfully');

        } catch (error) {
            console.error('Failed to initialize database:', error);
            showError('Failed to initialize database: ' + error.message);
            document.getElementById('dbStatus').textContent = 'Database initialization failed';
            updateCurrentTask('Database initialization failed');
        }
    }

        function updateCurrentTask(task) {
            const taskElement = document.getElementById('currentTask');
            if (taskElement) {
                taskElement.textContent = task;
            }
            console.log('Task:', task);
        }

    function updateDbStatus() {
        if (!db) return;

        try {
            // Use the correct SQLite WASM API for queries
            const stmt = db.prepare("SELECT COUNT(*) as count FROM books WHERE full_text IS NOT NULL");
            let count = 0;

            if (stmt.step()) {
                count = stmt.get(0); // Get first column value
            }
            stmt.finalize();

            document.getElementById('dbStatus').textContent = `Database ready - ${count} books indexed`;
            document.getElementById('indexedCount').textContent = count;

            // Show search section if we have indexed books
            if (count > 0) {
                document.getElementById('searchSection').style.display = 'block';
            }
        } catch (error) {
            console.error('Database status error:', error);
            document.getElementById('dbStatus').textContent = 'Database error';
        }
    }


        async function loadCollection() {
            const url = collectionInput.value.trim();

            if (!url) {
                showError('Please enter a collection URL');
                return;
            }

            showLoading();
            hideError();
            hideStats();
            clearBooks();
            processedBooks = [];

            try {
                updateCurrentTask('Loading collection...');

                const collectionResponse = await fetch(url);
                if (!collectionResponse.ok) {
                    throw new Error(`Failed to load collection: ${collectionResponse.status}`);
                }

                const collectionData = await collectionResponse.json();
                const editionKeys = extractEditionKeys(collectionData.body?.value || '');

                if (editionKeys.length === 0) {
                    throw new Error('No edition keys found in collection');
                }

                console.log(`Found ${editionKeys.length} edition keys`);
                showStats(editionKeys.length);

                // Process each edition
                for (let i = 0; i < editionKeys.length; i++) {
                    try {
                        updateCurrentTask(`Processing book ${i + 1}/${editionKeys.length}`);
                        await processEdition(editionKeys[i]);
                        updateProgress(i + 1, editionKeys.length);

                        if (i < editionKeys.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } catch (error) {
                        console.warn(`Error processing edition ${editionKeys[i]}:`, error);
                    }
                }

                hideLoading();
                updateCurrentTask('Collection loaded');
                downloadBtn.disabled = false;
                showSuccess(`Loaded ${processedBooks.length} books with Archive.org links`);

            } catch (error) {
                hideLoading();
                showError(error.message);
                updateCurrentTask('Error loading collection');
                console.error('Error loading collection:', error);
            }
        }

        async function downloadAllTexts() {
            if (processedBooks.length === 0) {
                showError('No books loaded. Please load a collection first.');
                return;
            }

            downloadBtn.disabled = true;
            updateCurrentTask('Starting text downloads...');

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < processedBooks.length; i++) {
                const book = processedBooks[i];
                updateCurrentTask(`Downloading text ${i + 1}/${processedBooks.length}: ${book.title}`);
                updateProgress(i, processedBooks.length);

                try {
                    await downloadBookText(book);
                    successCount++;
                    book.status = 'indexed';
                } catch (error) {
                    console.warn(`Failed to download text for ${book.title}:`, error);
                    book.status = 'failed';
                    book.error = error.message;
                    errorCount++;
                }

                displayBooks();
                updateDbStatus();

                // Small delay between downloads
                if (i < processedBooks.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }

            updateProgress(processedBooks.length, processedBooks.length);
            updateCurrentTask(`Complete: ${successCount} indexed, ${errorCount} failed`);
            downloadBtn.disabled = false;

            if (successCount > 0) {
                showSuccess(`Successfully indexed ${successCount} books for full-text search!`);
                document.getElementById('searchSection').style.display = 'block';
            }
        }

 async function downloadBookText(book) {
        if (!book.ocaid) {
            throw new Error('No Archive.org ID available');
        }

        // Check if already in database - use prepared statement
        const checkStmt = db.prepare("SELECT id FROM books WHERE ocaid = ?");
        checkStmt.bind([book.ocaid]);

        if (checkStmt.step()) {
            checkStmt.finalize();
            console.log(`Book ${book.title} already indexed`);
            return;
        }
        checkStmt.finalize();

        // Try to download the full text
        const textUrl = `https://archive.org/download/${book.ocaid}/${book.ocaid}_djvu.txt`;
        console.log(`Looking for ${textUrl}`)

        try {
            const response = await fetch(textUrl);
            if (!response.ok) {
                throw new Error(`Text file not available (${response.status})`);
            }

            const fullText = await response.text();

            if (fullText.trim().length === 0) {
                throw new Error('Text file is empty');
            }

            // Clean up the text a bit
            const cleanText = fullText
                .replace(/\f/g, '\n')  // Replace form feeds with newlines
                .replace(/\r\n/g, '\n')  // Normalize line endings
                .replace(/\n{3,}/g, '\n\n')  // Reduce multiple newlines
                .trim();

            console.log('Inserting:', book.ocaid, book.title);

            // Insert into database using prepared statement
            const insertStmt = db.prepare(`
            INSERT OR REPLACE INTO books 
            (ocaid, title, authors, work_key, edition_key, full_text) 
            VALUES (?, ?, ?, ?, ?, ?)
        `);

            insertStmt.bind([
                book.ocaid,
                book.title,
                book.authors.join(', '),
                book.workKey,
                book.key,
                cleanText
            ]);

            insertStmt.step();
            insertStmt.finalize();

            // Verify insertion
            const verifyStmt = db.prepare("SELECT id FROM books WHERE ocaid = ?");
            verifyStmt.bind([book.ocaid]);

            if (verifyStmt.step()) {
                console.log(`Successfully indexed: ${book.title} (${cleanText.length} characters)`);
            } else {
                console.error(`Failed to verify insertion for ${book.title}`);
            }
            verifyStmt.finalize();

        } catch (error) {
            throw new Error(`Failed to download text: ${error.message}`);
        }
    }

    async function performSearch() {
        const query = searchQuery.value.trim();
        if (!query) {
            showError('Please enter a search query');
            return;
        }

        if (isSearching) return;
        isSearching = true;

        try {
            updateCurrentTask('Searching...');

            // Use prepared statement for search
            const searchStmt = db.prepare(`
            SELECT 
                b.ocaid, b.title, b.authors, b.work_key, b.edition_key,
                snippet(books_fts, 2, '<mark class="highlight">', '</mark>', '...', 32) as snippet,
                bm25(books_fts) as rank
            FROM books_fts 
            JOIN books b ON books_fts.rowid = b.id
            WHERE books_fts MATCH ?
            ORDER BY rank
            LIMIT 50
        `);

            searchStmt.bind([query]);

            const results = [];
            while (searchStmt.step()) {
                results.push({
                    ocaid: searchStmt.get(0),
                    title: searchStmt.get(1),
                    authors: searchStmt.get(2),
                    workKey: searchStmt.get(3),
                    editionKey: searchStmt.get(4),
                    snippet: searchStmt.get(5),
                    rank: searchStmt.get(6)
                });
            }
            searchStmt.finalize();

            displaySearchResults(results, query);
            updateCurrentTask('Search complete');

        } catch (error) {
            console.error('Search error:', error);
            showError('Search failed: ' + error.message);
            updateCurrentTask('Search failed');
        } finally {
            isSearching = false;
        }
    }

    function displaySearchResults(results, query) {
        const resultsDiv = document.getElementById('searchResults');
        const resultsList = document.getElementById('searchResultsList');

        if (!results.length) {
            resultsList.innerHTML = '<p>No results found.</p>';
            resultsDiv.style.display = 'block';
            return;
        }

        resultsList.innerHTML = results.map(book => `
        <div class="book-card highlighted">
            <div class="book-title">${escapeHtml(book.title)}</div>
            <div class="book-authors">by ${escapeHtml(book.authors)}</div>
            <div class="search-snippet">${book.snippet}</div>
            <div class="book-links">
                <a href="https://archive.org/details/${book.ocaid}" target="_blank">üìö Archive.org</a>
                <a href="https://openlibrary.org${book.editionKey || book.workKey}" target="_blank" class="openlibrary">üìñ OpenLibrary</a>
            </div>
        </div>
    `).join('');

        resultsDiv.style.display = 'block';

        // Highlight matching books in main grid
        highlightBooksInGrid(results.map(b => b.ocaid));
    }

        function highlightBooksInGrid(ocaids) {
            const cards = document.querySelectorAll('.book-card');
            cards.forEach(card => {
                card.classList.remove('highlighted');
                const ocaid = card.dataset.ocaid;
                if (ocaid && ocaids.includes(ocaid)) {
                    card.classList.add('highlighted');
                }
            });
        }

        function clearSearch() {
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchQuery').value = '';

            // Remove highlights
            const cards = document.querySelectorAll('.book-card');
            cards.forEach(card => card.classList.remove('highlighted'));
        }

        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        }

    async function clearDatabase() {
        if (!confirm('Are you sure you want to clear all downloaded texts?')) {
            return;
        }

        try {
            db.exec("DELETE FROM books");
            updateDbStatus();
            updateCurrentTask('Database cleared');
            showSuccess('Database cleared successfully');
            document.getElementById('searchSection').style.display = 'none';

            // Update book status display
            processedBooks.forEach(book => {
                delete book.status;
                delete book.error;
            });
            displayBooks();

        } catch (error) {
            showError('Failed to clear database: ' + error.message);
        }
    }
        // [Previous utility functions remain the same]
        function extractEditionKeys(bodyText) {
            const editionKeyRegex = /\/books\/OL\w+/g;
            const workKeyRegex = /\/works\/OL\w+/g;

            const editionMatches = bodyText.match(editionKeyRegex) || [];
            const workMatches = bodyText.match(workKeyRegex) || [];

            const allKeys = [...editionMatches, ...workMatches];
            return [...new Set(allKeys)];
        }

        async function processEdition(key) {
            try {
                const isWorkKey = key.includes('/works/');

                if (isWorkKey) {
                    await processWorkForDefaultEdition(key);
                } else {
                    await processDirectEdition(key);
                }

            } catch (error) {
                console.warn(`Error processing ${key}:`, error);
            }
        }

        async function processDirectEdition(editionKey) {
            try {
                const editionResponse = await fetch(`https://openlibrary.org${editionKey}.json`);
                if (!editionResponse.ok) {
                    console.warn(`Failed to load edition ${editionKey}: ${editionResponse.status}`);
                    return;
                }

                const editionData = await editionResponse.json();

                if (editionData.ocaid) {
                    let workTitle = editionData.title;
                    let authors = [];

                    if (editionData.works && editionData.works.length > 0) {
                        try {
                            const workResponse = await fetch(`https://openlibrary.org${editionData.works[0].key}.json`);
                            if (workResponse.ok) {
                                const workData = await workResponse.json();
                                workTitle = workData.title || editionData.title;
                                authors = await getAuthors(workData.authors || []);
                            }
                        } catch (e) {
                            // Use edition data if work fetch fails
                        }
                    }

                    if (authors.length === 0 && editionData.authors) {
                        authors = await getAuthors(editionData.authors);
                    }

                    processedBooks.push({
                        workKey: editionData.works?.[0]?.key || null,
                        workTitle: workTitle,
                        key: editionKey,
                        title: editionData.title,
                        ocaid: editionData.ocaid,
                        isbn: editionData.isbn_13 || editionData.isbn_10 || [],
                        authors: authors
                    });

                    displayBooks();
                }

            } catch (error) {
                console.warn(`Error processing edition ${editionKey}:`, error);
            }
        }

        async function processWorkForDefaultEdition(workKey) {
            try {
                const workResponse = await fetch(`https://openlibrary.org${workKey}.json`);
                if (!workResponse.ok) {
                    console.warn(`Failed to load work ${workKey}: ${workResponse.status}`);
                    return;
                }

                const workData = await workResponse.json();

                const editionsResponse = await fetch(`https://openlibrary.org${workKey}/editions.json`);
                if (!editionsResponse.ok) {
                    console.warn(`Failed to load editions for ${workKey}: ${editionsResponse.status}`);
                    return;
                }

                const editionsData = await editionsResponse.json();

                if (editionsData.entries) {
                    for (const edition of editionsData.entries) {
                        if (edition.ocaid) {
                            const authors = await getAuthors(workData.authors || []);

                            processedBooks.push({
                                workKey: workKey,
                                workTitle: workData.title,
                                key: edition.key,
                                title: edition.title || workData.title,
                                ocaid: edition.ocaid,
                                isbn: edition.isbn_13 || edition.isbn_10 || [],
                                authors: authors
                            });

                            displayBooks();
                            break;
                        }
                    }
                }

            } catch (error) {
                console.warn(`Error processing work ${workKey}:`, error);
            }
        }

        async function getAuthors(authorRefs) {
            const authors = [];

            for (const authorRef of authorRefs.slice(0, 3)) {
                try {
                    if (authorRef.author?.key) {
                        const authorResponse = await fetch(`https://openlibrary.org${authorRef.author.key}.json`);
                        if (authorResponse.ok) {
                            const authorData = await authorResponse.json();
                            authors.push(authorData.name || 'Unknown Author');
                        }
                    } else if (authorRef.key) {
                        const authorResponse = await fetch(`https://openlibrary.org${authorRef.key}.json`);
                        if (authorResponse.ok) {
                            const authorData = await authorResponse.json();
                            authors.push(authorData.name || 'Unknown Author');
                        }
                    }
                } catch (e) {
                    // Ignore individual author fetch errors
                }
            }

            return authors;
        }

        function displayBooks() {
            const grid = document.getElementById('bookGrid');
            grid.innerHTML = '';

            processedBooks.forEach(book => {
                const card = document.createElement('div');
                card.className = 'book-card';
                card.dataset.ocaid = book.ocaid;

                const archiveLinks = book.ocaid ?
                    (Array.isArray(book.ocaid) ? book.ocaid : [book.ocaid]).map(id =>
                        `<a href="https://archive.org/details/${id}" target="_blank">üìö Archive.org</a>`
                    ).join('') : '';

                const workUrl = book.workKey ? `https://openlibrary.org${book.workKey}` : '';
                const editionUrl = book.key ? `https://openlibrary.org${book.key}` : workUrl;

                let statusDiv = '';
                if (book.status === 'indexed') {
                    statusDiv = '<div class="book-status indexed">‚úÖ Full text indexed</div>';
                } else if (book.status === 'failed') {
                    statusDiv = `<div class="book-status failed">‚ùå ${book.error || 'Text not available'}</div>`;
                }

                card.innerHTML = `
                    <div class="book-title">${escapeHtml(book.title)}</div>
                    <div class="book-authors">
                        ${book.authors.length > 0 ?
                        'by ' + book.authors.map(escapeHtml).join(', ') :
                        'Author unknown'
                    }
                    </div>
                    <div class="book-links">
                        ${archiveLinks}
                        <a href="${editionUrl}" target="_blank" class="openlibrary">üìñ OpenLibrary</a>
                    </div>
                    ${statusDiv}
                `;

                grid.appendChild(card);
            });
        }

        //function updateCurrentTask(task) {
        //    document.getElementById('currentTask').textContent = task;
       // }

        function updateProgress(current, total) {
            const percentage = Math.round((current / total) * 100);
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percentage + '%';
            progressBar.textContent = percentage + '%';
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            loadButton.disabled = true;
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
            loadButton.disabled = false;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 10000);
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('success');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 8000);
        }

        function showStats(count) {
            document.getElementById('workCount').textContent = count;
            document.getElementById('stats').style.display = 'block';
        }

        function hideStats() {
            document.getElementById('stats').style.display = 'none';
        }

        function clearBooks() {
            document.getElementById('bookGrid').innerHTML = '';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
    window.loadCollection = loadCollection;
      window.downloadAllTexts = downloadAllTexts;
window.handleSearchKeypress = handleSearchKeypress;
      window.performSearch = performSearch;
      
        </script>
        </body></html>